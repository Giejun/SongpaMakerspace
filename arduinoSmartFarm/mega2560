  /**
 * 
 * Design for operate Smart Farm using LED, FAN, and Sensors.
 * Board: Mega2560
 * Sensors: DHT22, DS18B20, Water Levels, DS3231
 * Actuators: Fan, Water Motor, LED Light Relay
 * Display : 2004 LCD, Rotary Encoder
 * 
 */

//------------------------------------ Include libraries --------------------------//
#include <OneWire.h>
#include <DallasTemperature.h> 
#include <SPI.h>
#include <Wire.h>
#include "DHT.h" 
#include <LiquidCrystal_I2C.h>   

#define BUZZER         13                     // buzzer alarm, 9, 12 lack of water
#define WATER_TANK     12                     // water level in tank
#define ONE_WIRE_BUS    7                     //DS18B20 water Temperature
#define DHTPIN          8                     //DHT22 Temp & Humi Sensor
#define FAN            39                     // to Control temp & Humidity use Fan FAN for Temp & Humi
#define LEDRelay       31                     //LED Light & Light Switch
#define TOUCHSW        10                     // for LED Light ON OFF
#define OXY            41                     // Supply Oxygent to water
#define WATER_PUMP     37                     // Supply Water from Tank  to Root


LiquidCrystal_I2C lcd(0x27,20,4);             // set the LCD address to 0x27 for a 16 chars and 2 line display
#define DS3231_I2C_ADDRESS 104                // DS3231's general addres ; 0x68, 0x57 to change decimal 0x57 is 87, 0x68 is 104

int BUZZER_State = LOW;                       //D13 Buzzer & Buzzer sound
const int onDuration = 1000;
const int periodDuration = 5000;
unsigned long lastPeriodStart;

OneWire oneWire(ONE_WIRE_BUS);                //D7, DS18B20 Temperature Sensor
DallasTemperature waterTemp(&oneWire);

#define DHTTYPE DHT22                         //D8, DHT22 Temp & Humi sensor
DHT dht(DHTPIN, DHTTYPE);


/****************************** Review & develop ******************************/
//temperature and humidity is over maxTemp or maxHumi, then Fan is ON

int FAN_readValue;                            // Fan for controlling temp & humi, and supply oxygen to leaf.
int maxHum = 30;                              // TO BE SET VALUE BY USED ROTARY ENCODER
int maxTemp = 25;



// LED Light set and restriced by touch switch
int LED_readValue;                            //D31 Relay for LED Light controlling

boolean TOUCHSW_currentState = LOW;           //LED Light is ON/OFF
boolean TOUCHSW_lastState = LOW;
boolean LEDRelay_state = LOW;

byte OnHour = 18;                           // LED Light On Hour
byte OnMin = 00;                            // LED Light On Minute
byte OffHour = 22;                          // LED Light Off Hour
byte OffMin = 03;                           // LED Light Off Minute

byte seconds, minutes, hours, day, date, month, year;
char weekDay[4];
byte tMSB, tLSB;
float my_temp;
char my_array[100];                                      // Character array for printing something.


/*********** develop PUMP, OXY set on off time with encoder  *****************/

const unsigned int pumpOnTime = 10*1000;                 // Control Water Pump ON TIME, SET TIME USE ENCODER
const unsigned int pumpOffTime = 30*1000;                // Control Water Pump OFF TIME, SET TIME USE ENCODER 
unsigned long pumpPreMillis = 0;
int pumpInterval = pumpOnTime;
boolean pumpState = true;

const unsigned int OxyOnTime = 5*1000;                 // Control Oxygen relay ON TIME, SET TIME USE ENCODER
const unsigned int OxyOffTime = 20*1000;                // Control Oxygen relay OFF TIME, SET TIME USE ENCODER 
unsigned long OxyPreMillis = 0;
int OxyInterval = OxyOnTime;
boolean OxyState = true;


void setup(){
  Serial.begin(57600);

  pinMode(BUZZER, OUTPUT);
  pinMode(WATER_TANK, INPUT_PULLUP);  
  pinMode(FAN, OUTPUT);
  pinMode(LEDRelay,OUTPUT);
  pinMode(TOUCHSW, INPUT);
  pinMode(OXY, OUTPUT);
  pinMode(WATER_PUMP,OUTPUT);
  digitalWrite(LEDRelay, LOW);  
  
  Wire.begin();
  waterTemp.begin();
  dht.begin(); 

  lcd.begin();                             // initialize the lcd 
  lcd.backlight();
  lcd.setCursor(2,1);
  lcd.print("www.DIYALL.TECH"); 
  lcd.setCursor(10,3);
  lcd.print("ver: 0.9");
  delay(3000);  
  lcd.clear();
  }

void loop(){ 

  //---------------------------------------------- DS18B20 ------------------------------------------------------//
  waterTemp.requestTemperatures();  
  Serial.print("Temperature is: ");
  Serial.println(waterTemp.getTempCByIndex(0));                        // Why "byIndex"? You can have more than one IC on the same bus. 0 refers to the first IC on the wire

  //---------------------------------------------- DHT22 ------------------------------------------------------//  
  float h = dht.readHumidity();
  float t = dht.readTemperature();
  float f = dht.readTemperature(true);  
  if (isnan(h) || isnan(t) || isnan(f)){                              // Check if any reads failed and exit early (to try again).
    Serial.println("Failed to read from DHT sensor!");
    return;
    }
   if(h > maxHum || t > maxTemp){                                    // FAN CONTROLED
    digitalWrite(FAN, HIGH);
   } 
  else{

    // 정기적 펜 동작 코드 삽입*************************************************************************************
    digitalWrite(FAN, LOW); 
   }
    
  Serial.print("T:");
  Serial.print(t);
  Serial.println("C");
  Serial.print("H:");
  Serial.print(h);
  Serial.println(" %");

  //---------------------------------------------- DS3231 RTC ------------------------------------------------------// 
  watchConsole(); 
  get3231Date();
  my_temp = (float)get3231Temp();

  //---------------------------------------------- Serial.print -------------------------------------------------//
  Serial.print(weekDay); 
  Serial.print(", "); 
  Serial.print(date, DEC); 
  Serial.print("/"); 
  Serial.print(month, DEC);
  Serial.print("/"); 
  Serial.print(year, DEC); 
  Serial.print(" - ");
  Serial.print(hours, DEC);
  Serial.print(":"); 
  Serial.print(minutes, DEC);
  Serial.print(":"); 
  Serial.println(seconds, DEC);
 
  Serial.print("RTC Temp: "); 
  Serial.println(my_temp);

 Serial.print("DS18B20:");
 Serial.println(waterTemp.getTempCByIndex(0));
  
  // NOTE: Arduino does NOT implement printing floats to a string.
  // If you use the std C function : sprintf(my_array, "Temp: %4.2f", my_temp), It will NOT CONVERT.
  // So I abandoned this, since I don't need to print the float to the LCD anyway.


//---------------------------- LED Relay ; ON OFF by DS3231 RTC CLOCK -------------------------------//

/**
 * I'd like to control LED Relay 2 ways. one is TOUCHSW, the other is RTC CLOCK setting
 * 1. With TOUCHSW(10), I want to ON / OFF LED Realy, at any time. in other word,without rtc clock setting condition, when ledrelay is on, touch sw, then led is off
 *    when led is off, touch switch(10) then led relay ON.
 * 2. LED realy is operated based on rtc setting value. when I set 18:00 led relay off, and 09:00 led relay On, then led is on 09:00  to 18:00 
 * 
 * This issue is explained at this link :  https://arduino.stackexchange.com/questions/17477/creating-a-timer-using-a-real-time-clock-with-start-and-stop-times?answertab=votes#tab-top
 *  
 */


/**
  TOUCHSW_currentState = digitalRead(TOUCHSW);
  if (TOUCHSW_currentState == HIGH && TOUCHSW_lastState == LOW){
     Serial.println("pressed");
     delay(1);
         
    if (LEDRelay_state == HIGH){
      digitalWrite(LEDRelay, LOW);
      LEDRelay_state = LOW;
     }
     else{
      digitalWrite(LEDRelay, HIGH);
      LEDRelay_state = HIGH;
    }
  }
  TOUCHSW_lastState = TOUCHSW_currentState;
**/
 
  if(hours == OnHour && minutes == OnMin){                        //using RTC colck, control LED Light
    digitalWrite(LEDRelay, HIGH);
    Serial.println("LIGHT ON");
  }
  else if(hours ==OffHour && minutes == OffMin){
    digitalWrite(LEDRelay, LOW);
    Serial.println("LIGHT OFF");
  }

//-------------------------------------------------- WATER TANK ALRAM -----------------------------------//

  int WATER_TANK_VAL = digitalRead(WATER_TANK);
   
 if(WATER_TANK_VAL == LOW){
    if(millis() - lastPeriodStart >= periodDuration) {
    lastPeriodStart += periodDuration;
    tone(BUZZER, 550, onDuration);
  } 
}
  Serial.println(WATER_TANK_VAL);  

//---------------------------------------- D37 Relay for water Pump --------------------//

digitalWrite(WATER_PUMP, pumpState);
unsigned long pumpCurrentMillis = millis();
if((unsigned long)(pumpCurrentMillis - pumpPreMillis) >= pumpInterval){
  if(pumpState){
    pumpInterval = pumpOffTime;
    Serial.println(pumpState);
  }
  else{
    pumpInterval = pumpOnTime;
  }
  pumpState = !(pumpState);
  pumpPreMillis = pumpCurrentMillis;
}

//---------------------------------------- D41 Relay for Oxygen --------------------//

digitalWrite(OXY, OxyState);
unsigned long OxyCurrentMillis = millis();
if((unsigned long)(OxyCurrentMillis - OxyPreMillis) >= pumpInterval){
  if(OxyState){
    OxyInterval = OxyOffTime;
    Serial.println(OxyState);
  }
  else{
   OxyInterval = OxyOnTime;
  }
  OxyState = !(OxyState);
  OxyPreMillis = OxyCurrentMillis;
}
 

 
//---------------------------------------- Display LCD 2004 ----------------------------------------//
 sprintf(my_array, "%d:%d:%d", hours, minutes, seconds);
  lcd.clear();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print(weekDay); 
  lcd.print(",");
  lcd.print(date, DEC); 
  lcd.print("/"); 
  lcd.print(month, DEC);
  lcd.print("/"); 
  lcd.print(year, DEC);
  lcd.setCursor(12, 0);
  lcd.print(my_array);
  lcd.setCursor(1, 2);
  lcd.print("T:");
  lcd.print(t);
  lcd.print("C");
  lcd.setCursor(11, 2);
  lcd.print("H:");
  lcd.print(h);
  lcd.print("%");
  lcd.setCursor(1, 3);
  lcd.print("WT:");
  lcd.print(waterTemp.getTempCByIndex(0));
  delay(1000);
}


// ------------------------------ DS3231 RCT ; Convert normal decimal numbers to binary coded decimal ------------------//
byte decToBcd(byte val){
  return ((val/10*16) + (val%10));
  }

void watchConsole(){
  if (Serial.available()){                                 // Look for char in serial queue and process if found
    if (Serial.read() == 84) {                             //If command = "T" Set Date
      set3231Date();
      get3231Date();
      Serial.println(" ");
      }
     }
}
 
void set3231Date(){
    //T(sec)(min)(hour)(dayOfWeek)(dayOfMonth)(month)(year)
    //T(00-59)(00-59)(00-23)(1-7)(01-31)(01-12)(00-99)
    //Example: 02-Feb-09 @ 19:57:11 for the 3rd day of the week -> T1157193020209
    // T1124154091014
  seconds = (byte) ((Serial.read() - 48) * 10 + (Serial.read() - 48));              // Use of (byte) type casting and ascii math to achieve result.  
  minutes = (byte) ((Serial.read() - 48) *10 +  (Serial.read() - 48));
  hours   = (byte) ((Serial.read() - 48) *10 +  (Serial.read() - 48));
  day     = (byte) (Serial.read() - 48);
  date    = (byte) ((Serial.read() - 48) *10 +  (Serial.read() - 48));
  month   = (byte) ((Serial.read() - 48) *10 +  (Serial.read() - 48));
  year    = (byte) ((Serial.read() - 48) *10 +  (Serial.read() - 48));
  Wire.beginTransmission(DS3231_I2C_ADDRESS);
  Wire.write(0x00);
  Wire.write(decToBcd(seconds));
  Wire.write(decToBcd(minutes));
  Wire.write(decToBcd(hours));
  Wire.write(decToBcd(day));
  Wire.write(decToBcd(date));
  Wire.write(decToBcd(month));
  Wire.write(decToBcd(year));
  Wire.endTransmission();
}

void get3231Date(){
  // send request to receive data starting at register 0
  Wire.beginTransmission(DS3231_I2C_ADDRESS);                 // 104 is DS3231 device address
  Wire.write(0x00); // start at register 0
  Wire.endTransmission();
  Wire.requestFrom(DS3231_I2C_ADDRESS, 7);                    // request seven bytes
  
  if(Wire.available()){
    seconds = Wire.read(); // get seconds
    minutes = Wire.read(); // get minutes
    hours   = Wire.read();   // get hours
    day     = Wire.read();
    date    = Wire.read();
    month   = Wire.read(); //temp month
    year    = Wire.read();
       
    seconds = (((seconds & B11110000)>>4)*10 + (seconds & B00001111)); // convert BCD to decimal
    minutes = (((minutes & B11110000)>>4)*10 + (minutes & B00001111)); // convert BCD to decimal
    hours   = (((hours & B00110000)>>4)*10 + (hours & B00001111)); // convert BCD to decimal (assume 24 hour mode)
    day     = (day & B00000111); // 1-7
    date    = (((date & B00110000)>>4)*10 + (date & B00001111)); // 1-31
    month   = (((month & B00010000)>>4)*10 + (month & B00001111)); //msb7 is century overflow
    year    = (((year & B11110000)>>4)*10 + (year & B00001111));
  }
  else{
    //oh noes, no data!
  }
 
  switch (day) {
    case 1:
      strcpy(weekDay, "Sun");  break;
    case 2:
      strcpy(weekDay, "Mon");  break;
    case 3:
      strcpy(weekDay, "Tue");  break;
    case 4:
      strcpy(weekDay, "Wed");  break;
    case 5:
      strcpy(weekDay, "Thu");  break;
    case 6:
      strcpy(weekDay, "Fri");  break;
    case 7:
      strcpy(weekDay, "Sat");  break;
  }
}

//-------------------------------- DS3231 Temperature Sensor -------------------------------//
float get3231Temp(){
  float temp3231;
  
  //temp registers (11h-12h) get updated automatically every 64s
  Wire.beginTransmission(DS3231_I2C_ADDRESS);
  Wire.write(0x11);
  Wire.endTransmission();
  Wire.requestFrom(DS3231_I2C_ADDRESS, 2);
 
  if(Wire.available()){
    tMSB = Wire.read();                                             //2's complement int portion
    tLSB = Wire.read();                                             //fraction portion
   
    temp3231 = (tMSB & B01111111); //do 2's math on Tmsb
    temp3231 += ( (tLSB >> 6) * 0.25 ); //only care about bits 7 & 8
  }
  else{
    //oh noes, no data!
  }   
  return temp3231;
}
